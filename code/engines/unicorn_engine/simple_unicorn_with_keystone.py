from unicorn import *
from unicorn.arm64_const import * 
from keystone import *
ARM64_CODE = (          # ARM64 code to be emulated 
    "mov w0, #0x5 ;"
    "add w0, w1, w0"
    )
ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN)   # Initialize keystone engine
ARM64_CODE, count = ks.asm(ARM64_CODE)
ARM64_CODE = bytes(ARM64_CODE)
ADDRESS = 0x1000000                             # memory address where emulation starts 
print(f"Emulating {count} ARM64 instructions") 
try: 
    mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)     # Initialize emulator in ARM64 (AARCH64) mode 
    mu.mem_map(ADDRESS, 2 * 1024 * 1024)    # map 2MB memory for this emulation 
    mu.mem_write(ADDRESS, ARM64_CODE)       # write machine code to be emulated to memory 
    mu.reg_write(UC_ARM64_REG_W1, 0x1)      # initialize machine registers
    mu.emu_start(ADDRESS, ADDRESS + len(ARM64_CODE))
    print("Emulation done. Below is the CPU context")
    r_W0 = mu.reg_read(UC_ARM64_REG_W0)
    print (f"W0 = {hex(r_W0)}")
except UcError as e:
    print("ERROR: %s" % e)
